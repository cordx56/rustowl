use anyhow::{Context, Result, anyhow};
use clap::Parser;
use std::{
    fmt::Write as _,
    path::{Path, PathBuf},
};

use crate::util::{Cmd, OsKind, is_ci, os_kind, repo_root, sudo_install, which, write_string};

#[derive(Parser, Debug)]
#[command(
    about = "Run security-oriented checks",
    long_about = "Runs a suite of security and correctness checks and writes logs to `security-logs/`.

Modes:
- default: run configured checks and write a summary Markdown file
- `--check`: print tool availability and exit
- `--install`: try installing missing tools (interactive mode)
- `--ci`: force CI mode (enables auto-install + verbose output)

Checks include:
- `cargo deny check` (run in CI `checks.yml`, not here)
- `cargo shear` (optional)
- `cargo nextest` (always)
- `cargo miri` (optional)
- valgrind (optional; platform-dependent)

In CI, this command can auto-install missing cargo tools and some OS packages."
)]
pub struct Args {
    /// Only check tool availability and exit (no tests)
    #[arg(long)]
    check: bool,

    /// Install missing tools in interactive mode
    #[arg(long)]
    install: bool,

    /// Force CI mode (enables auto-install and verbose logging)
    #[arg(long)]
    ci: bool,

    /// Disable auto-installation (even in CI mode)
    #[arg(long)]
    no_auto_install: bool,

    /// Skip Miri checks
    #[arg(long = "no-miri")]
    no_miri: bool,

    /// Skip valgrind checks
    #[arg(long = "no-valgrind")]
    no_valgrind: bool,

    /// Deprecated: cargo-deny is run in `checks.yml` (kept for compatibility)
    #[arg(long = "no-deny")]
    no_deny: bool,

    /// Skip `cargo shear`
    #[arg(long = "no-shear")]
    no_shear: bool,

    /// Skip macOS Instruments checks (currently no-op)
    #[arg(long = "no-instruments")]
    no_instruments: bool,
}

pub async fn run(args: Args) -> Result<()> {
    let root = repo_root()?;
    let logs_dir = root.join("security-logs");

    let ci_mode = args.ci || is_ci();
    let auto_install = !args.no_auto_install && (args.install || ci_mode);

    // Keep the flag for CLI parity with the legacy script.
    let _ = args.no_instruments;

    if ci_mode {
        eprintln!(
            "CI detected (auto-install: {})",
            if auto_install { "enabled" } else { "disabled" }
        );
    }

    if args.install && !auto_install {
        // This can happen if `--install` and `--no-auto-install` are both set.
        return Err(anyhow!("--install conflicts with --no-auto-install"));
    }

    // Keep parity with the shell scripts: require stable rustc >= .rust-version-stable.
    check_stable_rust_min_version(&root).await?;

    if args.check {
        print_tool_status(&root, ci_mode).await?;
        return Ok(());
    }

    let mut summary = String::new();
    writeln!(&mut summary, "# Security Testing Summary")?;
    writeln!(&mut summary)?;
    writeln!(&mut summary, "Generated by `cargo xtask security`.")?;
    writeln!(&mut summary)?;

    let mut overall_ok = true;

    // cargo-deny is intended for local runs; CI uses `checks.yml`.
    // To avoid duplicate CI cost, skip it when running under GitHub Actions.
    if !args.no_deny {
        if !ci_mode {
            ensure_cargo_tool("cargo-deny", "cargo-deny", auto_install).await?;
            let (ok, out) = run_and_capture(
                &root,
                "cargo-deny",
                Cmd::new("cargo").args(["deny", "check"]).cwd(&root),
            )
            .await;
            write_string(logs_dir.join("cargo-deny.log"), &out)?;
            overall_ok &= ok;
            append_step(
                &mut summary,
                "cargo deny",
                ok,
                Some("security-logs/cargo-deny.log"),
            );
        } else {
            append_step(
                &mut summary,
                "cargo deny",
                true,
                Some("skipped in CI (run via checks.yml)"),
            );
        }
    } else {
        append_step(&mut summary, "cargo deny", true, Some("skipped"));
    }

    if !args.no_shear {
        // `cargo shear` is used to detect unused dependencies.
        ensure_cargo_tool("cargo-shear", "cargo-shear", auto_install).await?;
        let (ok, out) = run_and_capture(
            &root,
            "cargo-shear",
            Cmd::new("cargo").args(["shear"]).cwd(&root),
        )
        .await;
        write_string(logs_dir.join("cargo-shear.log"), &out)?;
        overall_ok &= ok;
        append_step(
            &mut summary,
            "cargo shear",
            ok,
            Some("security-logs/cargo-shear.log"),
        );
    } else {
        append_step(&mut summary, "cargo shear", true, Some("skipped"));
    }

    // `cargo nextest` is preferred over `cargo test` for CI robustness.
    ensure_cargo_tool("cargo-nextest", "cargo-nextest", auto_install).await?;
    {
        let (ok, out) = run_and_capture(
            &root,
            "cargo-nextest",
            Cmd::new("cargo")
                .args([
                    "xtask",
                    "toolchain",
                    "cargo",
                    "nextest",
                    "run",
                    "--no-fail-fast",
                ])
                .cwd(&root),
        )
        .await;
        write_string(logs_dir.join("cargo-nextest.log"), &out)?;
        overall_ok &= ok;
        append_step(
            &mut summary,
            "cargo nextest",
            ok,
            Some("security-logs/cargo-nextest.log"),
        );
    }

    if !args.no_miri {
        // Miri requires nightly.
        ensure_miri(auto_install).await?;
        let (ok, out) = run_and_capture(
            &root,
            "miri",
            Cmd::new("cargo")
                .args([
                    "xtask",
                    "toolchain",
                    "cargo",
                    "+nightly",
                    "miri",
                    "test",
                    "-p",
                    "rustowl",
                ])
                .cwd(&root),
        )
        .await;
        write_string(logs_dir.join("miri.log"), &out)?;
        overall_ok &= ok;
        append_step(&mut summary, "miri", ok, Some("security-logs/miri.log"));
    } else {
        append_step(&mut summary, "miri", true, Some("skipped"));
    }

    if !args.no_valgrind {
        // Valgrind is Linux-first; macOS support is best-effort.
        ensure_valgrind(auto_install).await?;

        let (build_ok, build_out) = run_and_capture(
            &root,
            "build rustowl",
            Cmd::new("cargo")
                .args([
                    "xtask",
                    "toolchain",
                    "cargo",
                    "build",
                    "--release",
                    "-p",
                    "rustowl",
                ])
                .cwd(&root),
        )
        .await;
        write_string(logs_dir.join("build-rustowl.log"), &build_out)?;
        overall_ok &= build_ok;
        append_step(
            &mut summary,
            "build rustowl (release)",
            build_ok,
            Some("security-logs/build-rustowl.log"),
        );

        let bin = if root.join("target/release/rustowl.exe").is_file() {
            "./target/release/rustowl.exe"
        } else {
            "./target/release/rustowl"
        };

        let (ok, out) = run_and_capture(
            &root,
            "valgrind",
            Cmd::new("valgrind")
                .args([
                    "--leak-check=full",
                    "--error-exitcode=1",
                    bin,
                    "check",
                    "./perf-tests/dummy-package",
                ])
                .cwd(&root),
        )
        .await;
        write_string(logs_dir.join("valgrind.log"), &out)?;
        overall_ok &= ok;
        append_step(
            &mut summary,
            "valgrind",
            ok,
            Some("security-logs/valgrind.log"),
        );
    } else {
        append_step(&mut summary, "valgrind", true, Some("skipped"));
    }

    let summary_name = format!("security_summary_{}.md", timestamp());
    let summary_path = logs_dir.join(summary_name);
    write_string(&summary_path, &summary)?;

    if !overall_ok {
        return Err(anyhow!(
            "one or more security checks failed; see {}",
            summary_path.display()
        ));
    }

    Ok(())
}

fn append_step(summary: &mut String, name: &str, ok: bool, log: Option<&str>) {
    let _ = writeln!(summary, "## {name}");
    let _ = writeln!(summary, "- status: {}", if ok { "ok" } else { "failed" });
    if let Some(log) = log {
        let _ = writeln!(summary, "- log: {log}");
    }
    let _ = writeln!(summary);
}

async fn run_and_capture(root: &Path, name: &str, cmd: Cmd) -> (bool, String) {
    eprintln!("[security] running: {name}");

    match cmd.output().await {
        Ok(out) => {
            let mut s = String::new();
            s.push_str("stdout:\n");
            s.push_str(&String::from_utf8_lossy(&out.stdout));
            s.push_str("\n\nstderr:\n");
            s.push_str(&String::from_utf8_lossy(&out.stderr));
            s.push('\n');
            (
                out.status.success(),
                format!("cwd: {}\n\n{}", root.display(), s),
            )
        }
        Err(err) => (false, format!("cwd: {}\nerror: {err:#}\n", root.display())),
    }
}

fn timestamp() -> String {
    use std::time::{SystemTime, UNIX_EPOCH};
    let secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    secs.to_string()
}

async fn print_tool_status(root: &PathBuf, ci_mode: bool) -> Result<()> {
    let host = os_kind();
    println!("platform: {:?}", host);
    println!("ci: {}", ci_mode);

    println!(
        "cargo-deny: {}",
        if which("cargo-deny").is_some() {
            "yes"
        } else {
            "no"
        }
    );
    println!(
        "cargo-shear: {}",
        if which("cargo-shear").is_some() {
            "yes"
        } else {
            "no"
        }
    );
    println!(
        "cargo-nextest: {}",
        if Cmd::new("cargo")
            .args(["nextest", "--version"])
            .cwd(root)
            .output()
            .await
            .map(|o| o.status.success())
            .unwrap_or(false)
        {
            "yes"
        } else {
            "no"
        }
    );

    let has_miri = Cmd::new("rustup")
        .args(["component", "list", "--installed"])
        .output()
        .await
        .map(|out| String::from_utf8_lossy(&out.stdout).contains("miri"))
        .unwrap_or(false);
    println!("miri component: {}", if has_miri { "yes" } else { "no" });

    println!(
        "valgrind: {}",
        if which("valgrind").is_some() {
            "yes"
        } else {
            "no"
        }
    );

    Ok(())
}

async fn check_stable_rust_min_version(root: &PathBuf) -> Result<()> {
    let pinned = crate::util::read_to_string(root.join(".rust-version-stable"))?;
    let pinned = pinned.trim();
    if pinned.is_empty() {
        return Ok(());
    }

    let output = Cmd::new("rustc")
        .args(["--version"])
        .cwd(root)
        .output()
        .await?;
    let stdout = String::from_utf8_lossy(&output.stdout);
    let current = stdout.split_whitespace().nth(1).unwrap_or("").trim();
    if current.is_empty() {
        return Err(anyhow!("could not parse rustc version from: {stdout}"));
    }

    if compares_ge_semver(current, pinned) {
        Ok(())
    } else {
        Err(anyhow!(
            "rustc {current} is below required stable {pinned} (from .rust-version-stable)"
        ))
    }
}

fn compares_ge_semver(current: &str, required: &str) -> bool {
    fn parse(v: &str) -> Option<(u64, u64, u64)> {
        let v = v.split_once('-').map(|(a, _)| a).unwrap_or(v);
        let mut it = v.split('.');
        Some((
            it.next()?.parse().ok()?,
            it.next()?.parse().ok()?,
            it.next()?.parse().ok()?,
        ))
    }

    let Some(c) = parse(current) else {
        return false;
    };
    let Some(r) = parse(required) else {
        return false;
    };
    c >= r
}

async fn ensure_cargo_tool(bin: &str, crate_name: &str, auto_install: bool) -> Result<()> {
    if which(bin).is_some() {
        return Ok(());
    }
    if !auto_install {
        return Err(anyhow!(
            "required tool `{bin}` not found; install it with `cargo install {crate_name}`"
        ));
    }
    Cmd::new("cargo")
        .args(["install", crate_name])
        .run()
        .await
        .with_context(|| format!("install {crate_name}"))?;
    if which(bin).is_none() {
        return Err(anyhow!("tool {bin} still not found after install"));
    }
    Ok(())
}

async fn ensure_miri(auto_install: bool) -> Result<()> {
    // If it's already installed, keep this cheap.
    let installed = Cmd::new("rustup")
        .args(["component", "list", "--installed"])
        .output()
        .await
        .map(|out| String::from_utf8_lossy(&out.stdout).contains("miri"))
        .unwrap_or(false);

    if installed {
        return Ok(());
    }

    if !auto_install {
        return Err(anyhow!(
            "miri component is not installed; run `rustup component add miri --toolchain nightly`"
        ));
    }

    Cmd::new("rustup")
        .args(["component", "add", "miri", "--toolchain", "nightly"])
        .run()
        .await
        .context("rustup component add miri")?;
    Ok(())
}

async fn ensure_valgrind(auto_install: bool) -> Result<()> {
    if which("valgrind").is_some() {
        return Ok(());
    }

    if !auto_install {
        return Err(anyhow!(
            "valgrind not found; install it via your system package manager"
        ));
    }

    match os_kind() {
        OsKind::Linux => sudo_install(&["valgrind"]).await?,
        // The legacy script attempted this, but valgrind is generally unreliable on macOS.
        // We keep the behavior behind `auto_install` for parity.
        OsKind::Macos => sudo_install(&["valgrind"]).await?,
        _ => return Err(anyhow!("valgrind unsupported on this OS")),
    }
    if which("valgrind").is_none() {
        return Err(anyhow!("valgrind not found after install"));
    }
    Ok(())
}
